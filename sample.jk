-- Assignment:
let number = 42
-- also represented as
[@let "number" 42]

-- Conditional execution
let opposite = true
if opposite { number = -42 }
-- is really shorthand for..
[@let "opposite" true]
[@if
  opposite
  [@block [@assign number -42] ]
]

-- Chained if..elif..else
if name == "tim" { 42 }
elif name = "bob" { 13 }
else { 7 }
-- can also be written as
[@if
  [@eq name "tim"]
  [@block 42]
  [@eq name "bob"]
  [@block 13]
  [@block 7]
]

-- Conditional expressions
let age = 30
let adult = age >= 18 ? "yes" : "no"
-- looks like
[@let "age" 30]
[@let "adult"
  [@cond [@gte age 18] "yes" "no"]
]

-- Functions:
let square = {|x| x * x }
-- becomes
[@let "square"
  [@def ["x"]
    [@mul x x]
  ]
]

-- Lists:
let array = [
  [1 0 0 2]
  [0 1 0 0]
  [1 0 2 9]
  [0 0 0 1]
]
-- is simply
[@let "array" [
  [1 0 0 2]
  [0 1 0 0]
  [1 0 2 9]
  [0 0 0 1]
]]
 
-- List lookup
array.2.3               --> 9
-- is described as
[@get [@get array 2] 3]

-- List Manupulation
let animals = ["Lions" "Tigers" "Bears"]
--
[@let "animals" ["Lions" "Tigers" "Bears"]]


-- Length of list
#animals                  --> 3
--
[@len animals]

-- Some forms don't have special syntax and so you must use list form directly.
-- Pushing a new item on the list and returning the index
[@insert animals "Oh My!" nil] --> 3
-- Popping an item from the end of the list
[@remove animals nil]

-- List Aliases:
let math = [
  root:   Math.sqrt
  square: square
  cube:   {|x| x * square!(x) }
]
--
[@let "math" [
  root: [@get Math "sqrt"]
  square: square
  cube: [@def ["x"]
    [@mul
      x
      [@call square x]
    ]
  ]
]]

-- Map lookup
math.cube!(3)
--
[@call [@get math "cube"] 3]

-- dynamic alias lookup
[@set set dynamic value]

